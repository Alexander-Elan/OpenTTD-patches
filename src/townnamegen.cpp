/*
 * This file is part of OpenTTD.
 * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
 */

/** @file townnamegen.cpp Original town name generators. */

#include "stdafx.h"
#include "townnamegen.h"
#include "core/random_func.hpp"

#include "table/townname.h"


/**
 * Generates a number from given seed.
 * @param shift_by number of bits seed is shifted to the right
 * @param max generated number is in interval 0...max-1
 * @param seed seed
 * @return seed transformed to a number from given range
 */
static inline uint32 SeedChance(byte shift_by, int max, uint32 seed)
{
	return (GB(seed, shift_by, 16) * max) >> 16;
}

/**
 * Generates a number from given seed. Uses different algorithm than SeedChance().
 * @param shift_by number of bits seed is shifted to the right
 * @param max generated number is in interval 0...max-1
 * @param seed seed
 * @return seed transformed to a number from given range
 */
static inline uint32 SeedModChance(byte shift_by, int max, uint32 seed)
{
	/* This actually gives *MUCH* more even distribution of the values
	 * than SeedChance(), which is absolutely horrible in that. If
	 * you do not believe me, try with i.e. the Czech town names,
	 * compare the words (nicely visible on prefixes) generated by
	 * SeedChance() and SeedModChance(). Do not get discouraged by the
	 * never-use-modulo myths, which hold true only for the linear
	 * congruential generators (and Random() isn't such a generator).
	 * --pasky
	 * TODO: Perhaps we should use it for all the name generators? --pasky */
	return (seed >> shift_by) % max;
}


/**
 * Choose a string from a string array.
 * @param strs The string array to choose from.
 * @param seed The random seed.
 * @param shift_by The number of bits that the seed is shifted to the right.
 * @return A random string from the array.
 */
template <uint N>
static inline const char *choose_str (const char * const (&strs) [N],
	uint32 seed, uint shift_by)
{
	return strs [SeedChance (shift_by, N, seed)];
}

/**
 * Choose a string from a string array.
 * @param strs The string array to choose from.
 * @param seed The random seed.
 * @param shift_by The number of bits that the seed is shifted to the right.
 * @return A random string from the array.
 */
template <uint N>
static inline const char *choose_str_mod (const char * const (&strs) [N],
	uint32 seed, uint shift_by)
{
	return strs [SeedModChance (shift_by, N, seed)];
}


/**
 * Optionally append a string from an array to a buffer.
 * @param buf The buffer to append the string to.
 * @param strs The string array to choose from.
 * @param seed The random seed.
 * @param shift_by The number of bits that the seed is shifted to the right.
 * @param threshold The threshold value to actually append a string.
 */
template <uint N>
static inline void append_opt (stringb *buf, const char * const (&strs) [N],
	uint32 seed, uint shift_by, uint threshold)
{
	uint i = SeedChance (shift_by, N + threshold, seed);
	if (i >= threshold) buf->append (strs [i - threshold]);
}


/**
 * Replaces english curses and ugly letter combinations by nicer ones.
 * @param buf buffer with town name
 * @param original English (Original) generator was used
 */
static void ReplaceEnglishWords(char *buf, bool original)
{
	static const uint N = 9;
	static const char org[N + 1][4] = {
		{'C','u','n','t'}, {'S','l','a','g'}, {'S','l','u','t'},
		{'F','a','r','t'}, {'D','r','a','r'}, {'D','r','e','h'},
		{'F','r','a','r'}, {'G','r','a','r'}, {'B','r','a','r'},
		{'W','r','a','r'}
	};
	static const char rep[N + 2][4] = {
		{'E','a','s','t'}, {'P','i','t','s'}, {'E','d','i','n'},
		{'B','o','o','t'}, {'Q','u','a','r'}, {'B','a','s','h'},
		{'S','h','o','r'}, {'A','b','e','r'}, {'O','v','e','r'},
		{'I','n','v','e'}, {'S','t','a','n'}
	};

	assert (strlen(buf) >= 4);

	for (uint i = 0; i < N; i++) {
		if (memcmp (buf, org[i], 4) == 0) {
			memcpy (buf, rep[i], 4);
			return;
		}
	}

	if (memcmp (buf, org[N], 4) == 0) {
		memcpy (buf, rep[original ? N : N + 1], 4);
	}
}

/**
 * Generates English (Original) town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeEnglishOriginalTownName (stringb *buf, uint32 seed)
{
	static const char * const names_1[] = {
		"Great ", "Little ", "New ", "Fort ",
	};

	static const char * const names_2[] = {
		"Wr", "B", "C",  "Ch", "Br", "D", "Dr", "F", "Fr",
		"Fl", "G", "Gr", "H",  "L",  "M", "N",  "P", "Pr",
		"Pl", "R", "S",  "S",  "Sl", "T", "Tr", "W",
	};

	static const char * const names_3[] = {
		"ar", "a", "e", "in", "on", "u", "un", "en",
	};

	static const char * const names_4[] = {
		"n", "ning", "ding", "d", "", "t", "fing",
	};

	static const char * const names_5[] = {
		"ville", "ham",     "field", "ton",    "town",   "bridge",
		"bury",  "wood",    "ford",  "hall",   "ston",   "way",
		"stone", "borough", "ley",   "head",   "bourne", "pool",
		"worth", "hill",    "well",  "hattan", "burg",
	};

	static const char * const names_6[] = {
		"-on-sea", " Bay",  " Market", " Cross", " Bridge",
		" Falls",  " City", " Ridge",  " Springs",
	};

	size_t orig_length = buf->length();

	/* optional first segment */
	append_opt (buf, names_1, seed, 0, 50);

	/* mandatory middle segments */
	buf->append (choose_str (names_2, seed,  4));
	buf->append (choose_str (names_3, seed,  7));
	buf->append (choose_str (names_4, seed, 10));
	buf->append (choose_str (names_5, seed, 13));

	/* optional last segment */
	append_opt (buf, names_6, seed, 15, 60);

	/* Ce, Ci => Ke, Ki */
	if (buf->buffer[orig_length] == 'C' && (buf->buffer[orig_length + 1] == 'e' || buf->buffer[orig_length + 1] == 'i')) {
		buf->buffer[orig_length] = 'K';
	}

	assert (buf->length() - orig_length >= 4);
	ReplaceEnglishWords (&buf->buffer[orig_length], true);
}

/**
 * Generates English (Additional) town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeEnglishAdditionalTownName (stringb *buf, uint32 seed)
{
	static const char * const names_prefix[] = {
		"Great ", "Little ", "New ", "Fort ", "St. ", "Old ",
	};

	static const char * const names_1a[] = {
		"Pen", "Lough", "Stam", "Aber", "Acc", "Ex", "Ax", "Bre",
		"Cum", "Dun", "Fin", "Inver", "Kin", "Mon", "Nan", "Nant",
		"Pit", "Pol", "Pont", "Strath", "Tre", "Tilly", "Beck",
		"Canter", "Bath", "Liver", "Mal", "Ox", "Bletch", "Maccles",
		"Grim", "Wind", "Sher", "Gates", "Orp", "Brom", "Lewis",
		"Whit", "White", "Worm", "Tyne", "Avon", "Stan",
	};

	static const char * const names_1b1[] = {
		"Wr", "B", "C",  "Ch", "Br", "D", "Dr", "F", "Fr",
		"Fl", "G", "Gr", "H",  "L",  "M", "N",  "P", "Pr",
		"Pl", "R", "S",  "S",  "Sl", "T", "Tr", "W",
	};

	static const char * const names_1b2[] = {
		"ar", "a",  "e",  "in", "on", "u",
		"o",  "ee", "es", "ea", "un", "en",
	};

	static const char * const names_1b3a[] = {
		"n", "d", "", "t", "", "",
	};

	static const char * const names_1b3b[] = {
		"ning", "ding", "fing",
	};

	static const char * const names_2[] = {
		"ville", "ham", "field", "ton", "town", "borough", "bridge",
		"bury", "wood", "ditch", "ford", "hall", "dean", "leigh",
		"dore", "ston", "stow", "church", "wich", "low", "way",
		"stone", "minster", "ley", "head", "bourne", "pool", "worth",
		"hill", "well", "hattan", "burg", "berg", "burgh", "port",
		"stoke", "haven", "stable", "stock", "side", "brook", "don",
		"den", "down", "nor", "grove", "combe", "by", "say", "ney",
		"chester", "dale", "ness", "shaw", "thwaite",
	};

	static const char * const names_3[] = {
		"-on-sea", " Bay", " Market", " Beeches", " Common", " Park",
		" Heath", " Marsh", " Green", " Castle", " End", " Rivers",
		" Cross", " Bridge", " Falls", " City", " Ridge", " Springs",
	};

	size_t orig_length = buf->length();

	/* optional first segment */
	append_opt (buf, names_prefix, seed, 0, 50);

	if (SeedChance(3, 20, seed) >= 14) {
		buf->append (choose_str (names_1a, seed, 6));
	} else {
		buf->append (choose_str (names_1b1, seed, 6));
		buf->append (choose_str (names_1b2, seed, 9));
		if (SeedChance(11, 20, seed) >= 4) {
			buf->append (choose_str (names_1b3a, seed, 12));
		} else {
			buf->append (choose_str (names_1b3b, seed, 12));
		}
	}

	buf->append (choose_str (names_2, seed, 14));

	/* optional last segment */
	append_opt (buf, names_3, seed, 15, 60);

	assert (buf->length() - orig_length >= 4);
	ReplaceEnglishWords (&buf->buffer[orig_length], false);
}


/**
 * Generates Austrian town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeAustrianTownName (stringb *buf, uint32 seed)
{
	static const char * const names_a1[] = {
		"Bad ", "Deutsch ", "Gross ", "Klein ", "Markt ", "Maria ",
	};

	static const char * const names_a2[] = {
		"Aus", "Alten", "Braun", "V\xC3\xB6sl", "Mittern", "Nuss",
		"Neu", "Walters", "Breiten", "Eisen", "Feld", "Mittern",
		"Gall", "Obern", "Grat", "Heiligen", "Hof", "Holla", "Stein",
		"Eber", "Eggen", "Enzers", "Frauen", "Herren", "Hof",
		"H\xC3\xBCtt", "Kaisers", "K\xC3\xB6nigs", "Knittel", "Lang",
		"Ober", "Ollers", "Pfaffen", "Potten", "Salz", "Schwarz",
		"Stocker", "Unter", "Utten", "V\xC3\xB6sen", "Vill", "Weissen",
	};

	static const char * const names_a3[] = {
		"see", "bach", "dorf", "ach", "stein", "hofen", "au", "ach",
		"kirch", "kirchen", "kreuz", "brunn", "siedl", "markt",
		"wang", "haag",
	};

	static const char * const names_a4[] = {
		"Bruck", "Brunn", "Gams", "Grein", "Ried", "Faak", "Zell",
		"Spital", "Kirchberg", "Saal", "Taferl", "Wald",
	};

	static const char * const names_a5[] = {
		"St. ", "Sankt ",
	};

	static const char * const names_a6[] = {
		"Aegyd", "Andr\xC3\xA4", "Georgen", "Jakob", "Johann",
		"Leonhard", "Marein", "Lorenzen", "Margarethen", "Martin",
		"Michael", "Nikolai", "Oswald", "Peter", "P\xC3\xB6lten",
		"Stefan", "Stephan", "Thomas", "Veit", "Wolfgang",
	};

	static const char * const names_f1[] = {
		" an der ", " ob der ",
	};

	static const char * const names_f2[] = {
		"Donau", "Steyr", "Lafnitz", "Leitha", "Thaya", "Gail",
		"Drau", "Salzach", "Ybbs", "Traisen", "Enns", "Mur", "Ill",
	};

	static const char * const names_b1[] = {
		" am ",
	};

	static const char * const names_b2[] = {
		"Brenner", "Dachstein", "Gebirge", "Grossglockner", "Hausruck",
		"Semmering", "Wagram", "Wechsel", "Wilden Kaiser", "Ziller",
	};

	/* Bad, Maria, Gross, ... */
	append_opt (buf, names_a1, seed, 0, 15);

	int j = 0;

	int i = SeedChance(4, 6, seed);
	if (i >= 4) {
		/* Kaisers-kirchen */
		buf->append (choose_str (names_a2, seed,  7));
		buf->append (choose_str (names_a3, seed, 13));
	} else if (i >= 2) {
		/* St. Johann */
		buf->append (choose_str (names_a5, seed, 7));
		buf->append (choose_str (names_a6, seed, 9));
		j = 1; // More likely to have a " an der " or " am "
	} else {
		/* Zell */
		buf->append (choose_str (names_a4, seed, 7));
	}

	i = SeedChance(1, 6, seed);
	if (i >= 4 - j) {
		/* an der Donau (rivers) */
		buf->append (choose_str (names_f1, seed, 4));
		buf->append (choose_str (names_f2, seed, 5));
	} else if (i >= 2 - j) {
		/* am Dachstein (mountains) */
		buf->append (choose_str (names_b1, seed, 4));
		buf->append (choose_str (names_b2, seed, 5));
	}
}


/**
 * Generates German town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeGermanTownName (stringb *buf, uint32 seed)
{
	static const char * const names_real[] = {
		"Berlin", "Bonn", "Bremen", "Cottbus", "Chemnitz", "Dortmund",
		"Dresden", "Erfurt", "Erlangen", "Essen", "Fulda", "Gera",
		"Kassel", "Kiel", "K\xC3\xB6ln", "L\xC3\xBC""beck",
		"Magdeburg", "M\xC3\xBCnchen", "Potsdam", "Stuttgart",
		"Wiesbaden",
	};

	static const char * const names_pre[] = {
		"Bad ", "Klein ", "Neu ",
	};

	static const char * const names_1[] = {
		"Alb", "Als", "Ander", "Arns", "Bruns", "Bam", "Biele",
		"Cloppen", "Co", "Duis", "D\xC3\xBCssel", "Dannen", "Elb",
		"Els", "Elster", "Eichen", "Ems", "Fahr", "Falken", "Flens",
		"Frank", "Frei", "Freuden", "Fried", "F\xC3\xBCrsten", "Hahn",
		"Ham", "Harz", "Heidel", "Hers", "Herz", "Holz", "Hildes",
		"Inns", "Ilsen", "Ingols", "Kel", "Kies", "Korn", "Kor",
		"Kreuz", "Kulm", "Langen", "Lim", "Lohr", "L\xC3\xBCne",
		"Mel", "Michels", "M\xC3\xBChl", "Naum", "Nest", "Nord",
		"Nort", "Nien", "Nidda", "Nieder", "N\xC3\xBCrn", "Ober",
		"Offen", "Osna", "Olden", "Ols", "Oranien", "Pader",
		"Quedlin", "Quer", "Ravens", "Regens", "Rott", "Ros",
		"R\xC3\xBCssels", "Saal", "Saar", "Salz", "Sch\xC3\xB6ne",
		"Schwein", "Sonder", "Sonnen", "Stein", "Strals", "Straus",
		"S\xC3\xBC""d", "Ton", "Unter", "Ur", "Vor", "Wald", "War",
		"Wert", "Wester", "Witten", "Wolfs", "W\xC3\xBCrz",
	};

	static const char * const names_2[] = {
		"bach", "berg", "br\xC3\xBC""ck", "br\xC3\xBC""cken", "burg",
		"dorf", "feld", "furt", "hausen", "haven", "heim", "horst",
		"mund", "m\xC3\xBCnster", "stadt", "wald",
	};

	static const char * const names_3_an_der[] = {
		" an der ",
	};

	static const char * const names_3_am[] = {
		" am ",
	};

	static const char * const names_4_an_der[] = {
		"Oder", "Spree", "Donau", "Saale", "Elbe",
	};

	static const char * const names_4_am[] = {
		"Main",
	};

	uint seed_derivative = SeedChance(7, 28, seed);

	/* optional prefix */
	if (seed_derivative == 12 || seed_derivative == 19) {
		buf->append (choose_str (names_pre, seed, 2));
	}

	/* mandatory middle segments including option of hardcoded name */
	uint i = SeedChance (3, lengthof(names_real) + lengthof(names_1), seed);
	if (i < lengthof(names_real)) {
		buf->append (names_real[i]);
	} else {
		buf->append (names_1 [i - lengthof(names_real)]);
		buf->append (choose_str (names_2, seed, 5));
	}

	/* optional suffix */
	if (seed_derivative == 24) {
		i = SeedChance (9, lengthof(names_4_an_der) + lengthof(names_4_am), seed);
		if (i < lengthof(names_4_an_der)) {
			buf->append (names_3_an_der[0]);
			buf->append (names_4_an_der[i]);
		} else {
			buf->append (names_3_am[0]);
			buf->append (names_4_am [i - lengthof(names_4_an_der)]);
		}
	}
}


/**
 * Generates Latin-American town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeSpanishTownName (stringb *buf, uint32 seed)
{
	static const char * const names_real[] = {
		"Caracas", "Maracay", "Maracaibo", "Valencia", "El Dorado",
		"Morrocoy", "Cata", "Cataito", "Ciudad Bol\xC3\xADvar",
		"Barquisimeto", "M\xC3\xA9rida", "Puerto Ordaz",
		"Santa Elena", "San Juan", "San Luis", "San Rafael",
		"Santiago", "Barcelona", "Barinas", "San Crist\xC3\xB3""bal",
		"San Fransisco", "San Mart\xC3\xADn", "Guayana", "San Carlos",
		"El Lim\xC3\xB3n", "Coro", "Corocoro", "Puerto Ayacucho",
		"Elorza", "Arismendi", "Trujillo", "Carupano", "Anaco",
		"Lima", "Cuzco", "Iquitos", "Callao", "Huacho", "Camana",
		"Puerto Chala", "Santa Cruz", "Quito", "Cuenca", "Huacho",
		"Tulc\xC3\xA1n", "Esmeraldas", "Ibarra", "San Lorenzo",
		"Macas", "Morana", "Machala", "Zamora", "Latacunga", "Tena",
		"Cochabamba", "Ascensi\xC3\xB3n", "Magdalena", "Santa Ana",
		"Manoa", "Sucre", "Oruro", "Uyuni", "Potos\xC3\xAD", "Tupiza",
		"La Quiaca", "Yacuiba", "San Borja", "Fuerte Olimpio",
		"Fort\xC3\xADn Esteros", "Campo Grande", "Bogota", "El Banco",
		"Zaragoza", "Neiva", "Mariano", "Cali", "La Palma", "Andoas",
		"Barranca", "Montevideo", "Valdivia", "Arica", "Temuco",
		"Tocopilla", "Mendoza", "Santa Rosa",
	};

	buf->append (choose_str (names_real, seed, 0));
}


/**
 * Generates French town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeFrenchTownName (stringb *buf, uint32 seed)
{
	static const char * const names_real[] = {
		"Agincourt", "Lille", "Dinan", "Aubusson", "Rodez",
		"Bergerac", "Bordeaux", "Bayonne", "Montpellier",
		"Mont\xC3\xA9limar", "Valence", "Digne", "Nice", "Cannes",
		"St. Tropez", "Marseille", "Narbonne", "S\xC3\xA8te",
		"Aurillac", "Gu\xC3\xA9ret", "Le Creusot", "Nevers",
		"Auxerre", "Versailles", "Meaux", "Ch\xC3\xA2lons",
		"Compi\xC3\xA8gne", "Metz", "Chaumont", "Langres", "Bourg",
		"Lyon", "Vienne", "Grenoble", "Toulon", "Rennes", "Le Mans",
		"Angers", "Nantes", "Ch\xC3\xA2teauroux", "Orl\xC3\xA9""ans",
		"Lisieux", "Cherbourg", "Morlaix", "Cognac", "Agen", "Tulle",
		"Blois", "Troyes", "Charolles", "Grenoble", "Chamb\xC3\xA9ry",
		"Tours", "St. Brieuc", "St. Malo", "La Rochelle", "St. Flour",
		"Le Puy", "Vichy", "St. Valery", "Beaujolais", "Narbonne",
		"Albi", "Paris", "Biarritz", "B\xC3\xA9ziers", "N\xC3\xAEmes",
		"Chamonix", "Angoul\xC3\xA8me", "Alen\xC3\xA7on",
	};

	buf->append (choose_str (names_real, seed, 0));
}


/**
 * Generates Silly town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeSillyTownName (stringb *buf, uint32 seed)
{
	static const char * const names_1[] = {
		"Binky", "Blubber", "Bumble", "Crinkle", "Crusty", "Dangle",
		"Dribble", "Flippety", "Google", "Muffin", "Nosey", "Pinker",
		"Quack", "Rumble", "Sleepy", "Sliggles", "Snooze", "Teddy",
		"Tinkle", "Twister", "Pinker", "Hippo", "Itchy", "Jelly",
		"Jingle", "Jolly", "Kipper", "Lazy", "Frogs", "Mouse",
		"Quack", "Cheeky", "Lumpy", "Grumpy", "Mangle", "Fiddle",
		"Slugs", "Noodles", "Poodles", "Shiver", "Rumble", "Pixie",
		"Puddle", "Riddle", "Rattle", "Rickety", "Waffle", "Sagging",
		"Sausage", "Egg", "Sleepy", "Scatter", "Scramble", "Silly",
		"Simple", "Trickle", "Slippery", "Slimey", "Slumber", "Soggy",
		"Sliggles", "Splutter", "Sulky", "Swindle", "Swivel", "Tasty",
		"Tangle", "Toggle", "Trotting", "Tumble", "Snooze", "Water",
		"Windy", "Amble", "Bubble", "Cheery", "Cheese", "Cockle",
		"Cracker", "Crumple", "Teddy", "Evil", "Fairy", "Falling",
		"Fishy", "Fizzle", "Frosty", "Griddle",
	};

	static const char * const names_2[] = {
		"ton", "bury", "bottom", "ville", "well", "weed", "worth",
		"wig", "wick", "wood", "pool", "head", "burg", "gate",
		"bridge",
	};

	buf->append (choose_str (names_1, seed,  0));
	buf->append (choose_str (names_2, seed, 16));
}


/**
 * Generates Swedish town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeSwedishTownName (stringb *buf, uint32 seed)
{
	static const char * const names_1[] = {
		"Gamla ", "Lilla ", "Nya ", "Stora ",
	};

	static const char * const names_2[] = {
		"Boll", "Bor", "Ed", "En", "Erik", "Es", "Fin", "Fisk",
		"Gr\xC3\xB6n", "Hag", "Halm", "Karl", "Kram", "Kung", "Land",
		"Lid", "Lin", "Mal", "Malm", "Marie", "Ner", "Norr", "Oskar",
		"Sand", "Skog", "Stock", "Stor", "Str\xC3\xB6m", "Sund",
		"S\xC3\xB6""der", "Tall", "Tratt", "Troll", "Upp", "Var",
		"V\xC3\xA4ster", "\xC3\x84ngel", "\xC3\x96ster",
	};

	static const char * const names_2a[] = {
		"B", "Br", "D", "Dr", "Dv", "F", "Fj", "Fl", "Fr", "G", "Gl",
		"Gn", "Gr", "H", "J", "K", "Kl", "Kn", "Kr", "Kv", "L", "M",
		"N", "P", "Pl", "Pr", "R", "S", "Sk", "Skr", "Sl", "Sn", "Sp",
		"Spr", "St", "Str", "Sv", "T", "Tr", "Tv", "V", "Vr",
	};

	static const char * const names_2b[] = {
		"a", "e", "i", "o", "u", "y",
		"\xC3\xA5", "\xC3\xA4", "\xC3\xB6",
	};

	static const char * const names_2c[] = {
		"ck", "d",  "dd", "g",  "gg", "l", "ld", "m",  "n",
		"nd", "ng", "nn", "p",  "pp", "r", "rd", "rk", "rp",
		"rr", "rt", "s",  "sk", "st", "t", "tt", "v",
	};

	static const char * const names_3[] = {
		"arp", "berg", "boda", "borg", "bro", "bukten", "by", "byn",
		"fors", "hammar", "hamn", "holm", "hus", "h\xC3\xA4ttan",
		"kulle", "k\xC3\xB6ping", "lund", "l\xC3\xB6v", "sala",
		"skrona", "sl\xC3\xA4tt", "sp\xC3\xA5ng", "stad", "sund",
		"svall", "svik", "s\xC3\xA5ker", "udde", "valla", "viken",
		"\xC3\xA4lv", "\xC3\xA5s",
	};

	/* optional first segment */
	append_opt (buf, names_1, seed, 0, 50);

	/* mandatory middle segments including option of hardcoded name */
	if (SeedChance(4, 5, seed) >= 3) {
		buf->append (choose_str (names_2, seed, 7));
	} else {
		buf->append (choose_str (names_2a, seed,  7));
		buf->append (choose_str (names_2b, seed, 10));
		buf->append (choose_str (names_2c, seed, 13));
	}

	buf->append (choose_str (names_3, seed, 16));
}


/**
 * Generates Dutch town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeDutchTownName (stringb *buf, uint32 seed)
{
	static const char * const names_1[] = {
		"Nieuw ", "Oud ",  "Groot ", "Zuid ",
		"Noord ", "Oost ", "West ",  "Klein ",
	};

	static const char * const names_2[] = {
		"Hoog", "Laag", "Zuider", "Zuid", "Ooster", "Oost", "Wester",
		"West", "Hoofd", "Midden", "Eind", "Amster", "Amstel", "Dord",
		"Rotter", "Haar", "Til", "Enk", "Dok", "Veen", "Leidsch",
		"Lely", "En", "Kaats", "U", "Maas", "Mar", "Bla", "Al", "Alk",
		"Eer", "Drie", "Ter", "Groes", "Goes", "Soest", "Coe", "Uit",
		"Zwaag", "Hellen", "Slie", "IJ", "Grubben", "Groen", "Lek",
		"Ridder", "Schie", "Olde", "Roose", "Haar", "Til", "Loos",
		"Hil",
	};

	static const char * const names_3[] = {
		"Drog", "Nat", "Valk", "Bob", "Dedem", "Kollum", "Best",
		"Hoend", "Leeuw", "Graaf", "Uithuis", "Purm", "Hard", "Hell",
		"Werk", "Spijk", "Vink", "Wams", "Heerhug", "Koning",
	};

	static const char * const names_4[] = {
		"e", "er", "el", "en", "o", "s",
	};

	static const char * const names_5[] = {
		"stad", "vorst", "dorp", "dam", "beek", "doorn", "zijl",
		"zijlen", "lo", "muiden", "meden", "vliet", "nisse", "daal",
		"vorden", "vaart", "mond", "zaal", "water", "duinen", "heuvel",
		"geest", "kerk", "meer", "maar", "hoorn", "rade", "wijk",
		"berg", "heim", "sum", "richt", "burg", "recht", "drecht",
		"trecht", "tricht", "dricht", "lum", "rum", "halen", "oever",
		"wolde", "veen", "hoven", "gast", "kum", "hage", "dijk",
		"zwaag", "pomp", "huizen", "bergen", "schede", "mere", "end",
	};

	/* optional first segment */
	append_opt (buf, names_1, seed, 0, 50);

	/* mandatory middle segments including option of hardcoded name */
	if (SeedChance(6, 9, seed) > 4) {
		buf->append (choose_str (names_2, seed,  9));
	} else {
		buf->append (choose_str (names_3, seed,  9));
		buf->append (choose_str (names_4, seed, 12));
	}

	buf->append (choose_str (names_5, seed, 15));
}


/**
 * Generates Finnish town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeFinnishTownName (stringb *buf, uint32 seed)
{
	static const char * const names_real[] = {
		"Aijala", "Kisko", "Espoo", "Helsinki", "Tapiola",
		"J\xC3\xA4rvel\xC3\xA4", "Lahti", "Kotka", "Hamina",
		"Loviisa", "Kouvola", "Tampere", "Oulu", "Salo", "Malmi",
		"Pelto", "Koski", "Iisalmi", "Raisio", "Taavetti", "Joensuu",
		"Imatra", "Tapanila", "Pasila", "Turku", "Kupittaa", "Vaasa",
		"Pori", "Rauma", "Kolari", "Lieksa",
	};

	static const char * const names_1[] = {
		"Hiekka", "Haapa", "Mylly", "Sauna", "Uusi", "Vanha",
		"Kes\xC3\xA4", "Kuusi", "Pelto", "Tuomi", "Terva", "Olki",
		"Hein\xC3\xA4", "Sein\xC3\xA4", "Rova", "Koivu", "Kokko",
		"M\xC3\xA4nty", "Pihlaja", "Pet\xC3\xA4j\xC3\xA4", "Kielo",
		"Kauha", "Viita", "Kivi", "Riihi", "\xC3\x84\xC3\xA4ne",
		"Niini",
	};

	static const char * const names_2[] = {
		"Lappeen", "Lohjan", "Savon", "Lapin", "Pit\xC3\xA4j\xC3\xA4n",
		"Martin", "Kuusan", "Kemi", "Keri", "H\xC3\xA4meen", "Kangas",
	};

	static const char * const names_3[] = {
		"harju", "linna", "j\xC3\xA4rvi", "kallio", "m\xC3\xA4ki",
		"nummi", "joki", "kyl\xC3\xA4", "lampi", "lahti",
		"mets\xC3\xA4", "suo", "laakso", "niitty", "luoto", "hovi",
		"ranta", "koski", "salo",
	};

	/* Select randomly if town name should consists of one or two parts. */
	if (SeedChance(0, 15, seed) >= 10) {
		buf->append (choose_str (names_real, seed, 2));
		return;
	}

	if (SeedChance(0, 15, seed) >= 5) {
		const char *orig = &buf->buffer[buf->length()];

		/* A two-part name by combining one of names_1 + "la"/"lä"
		 * The reason for not having the contents of names_{1,2} in the same table is
		 * that the ones in names_2 are not good for this purpose. */
		buf->append (choose_str (names_1, seed, 0));
		assert (!buf->empty());
		char *end = &buf->buffer[buf->length() - 1];
		assert(end >= orig);
		if (*end == 'i') *end = 'e';
		if (strstr(orig, "a") != NULL || strstr(orig, "o") != NULL || strstr(orig, "u") != NULL ||
				strstr(orig, "A") != NULL || strstr(orig, "O") != NULL || strstr(orig, "U")  != NULL) {
			buf->append ("la");
		} else {
			buf->append ("l\xC3\xA4");
		}
		return;
	}

	/* A two-part name by combining one of names_{1,2} + names_3.
	 * Why aren't names_{1,2} just one table? See above. */
	uint sel = SeedChance(2, lengthof(names_1) + lengthof(names_2), seed);
	if (sel >= lengthof(names_1)) {
		buf->append (names_2 [sel - lengthof(names_1)]);
	} else {
		buf->append (names_1[sel]);
	}

	buf->append (choose_str (names_3, seed, 10));
}


/**
 * Generates Polish town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakePolishTownName (stringb *buf, uint32 seed)
{
	static const char * const names_1_m[] = {
		"Wielki ", "Ma\xC5\x82y ", "Z\xC5\x82y ", "Dobry ",
		"Nowy ", "Stary ", "Z\xC5\x82oty ", "Zielony ",
		"Bia\xC5\x82y ", "Modry ", "D\xC4\x99""bowy ",
	};

	static const char * const names_1_f[] = {
		"Wielka ", "Ma\xC5\x82""a ", "Z\xC5\x82""a ", "Dobra ",
		"Nowa ", "Stara ", "Z\xC5\x82ota ", "Zielona ",
		"Bia\xC5\x82""a ", "Modra ", "D\xC4\x99""bowa ",
	};

	static const char * const names_1_n[] = {
		"Wielkie ", "Ma\xC5\x82""e ", "Z\xC5\x82""e ", "Dobre ",
		"Nowe ", "Stare ", "Z\xC5\x82ote ", "Zielone ",
		"Bia\xC5\x82""e ", "Modre ", "D\xC4\x99""bowe ",
	};

	static const char * const names_2_o[] = {
		"Frombork", "Gniezno", "Olsztyn", "Toru\xC5\x84",
		"Bydgoszcz", "Terespol", "Krak\xC3\xB3w", "Pozna\xC5\x84",
		"Wroc\xC5\x82""aw", "Katowice", "Cieszyn", "Bytom",
		"Frombork", "Hel", "Konin", "Lublin", "Malbork", "Sopot",
		"Sosnowiec", "Gda\xC5\x84sk", "Gdynia", "Sieradz",
		"Sandomierz", "Szczyrk", "Szczytno", "Szczecin", "Zakopane",
		"Szklarska Por\xC4\x99""ba", "Bochnia", "Golub-Dobrzyn",
		"Chojnice", "Ostrowiec", "Otwock", "Wolsztyn",
	};

	static const char * const names_2_m[] = {
		"Jarocin", "Gogolin", "Tomasz\xC3\xB3w", "Piotrk\xC3\xB3w",
		"Lidzbark", "Rypin", "Radzymin", "Wo\xC5\x82omin",
		"Pruszk\xC3\xB3w", "Olsztynek", "Rypin", "Cisek",
		"Krotoszyn", "Stoczek", "Lubin", "Lubicz", "Milicz", "Targ",
		"Ostr\xC3\xB3w", "Ozimek", "Puck", "Rzepin", "Siewierz",
		"Stargard", "Starogard", "Turek", "Tymbark", "Wolsztyn",
		"Strzepcz", "Strzebielin", "Sochaczew", "Gr\xC4\x99""bocin",
		"Gniew", "Lubliniec", "Lubasz", "Lutomiersk", "Niemodlin",
		"Przeworsk", "Ursus", "Tyczyn", "Sztum", "Szczebrzeszyn",
		"Wolin", "Wrzeszcz", "Zgierz", "Zieleniec", "Drobin",
		"Garwolin",
	};

	static const char * const names_2_f[] = {
		"Szprotawa", "Pogorzelica", "Mot\xC5\x82""awa", "Lubawa",
		"Nidzica", "Kruszwica", "Bierawa", "Brodnica", "Chojna",
		"Krzepica", "Ruda", "Rumia", "Tuchola", "Trzebinia", "Ustka",
		"Warszawa", "Bobowa", "Dukla", "Krynica", "Murowana",
		"Niemcza", "Zaspa", "Zawoja", "Wola", "Limanowa", "Rabka",
		"Skawina", "Pilawa",
	};

	static const char * const names_2_n[] = {
		"Lipsko", "Pilzno", "Przodkowo", "Strzelno", "Susz",
		"Jaworzno", "Choszczno", "Mogilno", "Luzino", "Miasto",
		"Dziadowo", "Kowalewo", "Legionowo", "Miastko", "Zabrze",
		"Zawiercie", "Kochanowo", "Miechucino", "Mirachowo",
		"Robakowo", "Kosakowo", "Borne", "Braniewo", "Sulinowo",
		"Chmielno", "Jastrz\xC4\x99""bie", "Gryfino", "Koronowo",
		"Lubichowo", "Opoczno",
	};

	static const char * const names_3_m[] = {
		" Wybudowanie", " \xC5\x9Awi\xC4\x99tokrzyski",
		" G\xC3\xB3rski", " Morski", " Zdr\xC3\xB3j", " Wody",
		" Bajoro", " Kraje\xC5\x84ski", " \xC5\x9Al\xC4\x85ski",
		" Mazowiecki", " Pomorski", " Wielki", " Maly",
		" Warmi\xC5\x84ski", " Mazurski", " Mniejszy",
		" Wi\xC4\x99kszy", " G\xC3\xB3rny", " Dolny", " Wielki",
		" Stary", " Nowy", " Wielkopolski", " Wzg\xC3\xB3rze",
		" Mosty", " Kujawski", " Ma\xC5\x82opolski", " Podlaski",
		" Lesny",
	};

	static const char * const names_3_f[] = {
		" Wybudowanie", " \xC5\x9Awi\xC4\x99tokrzyska",
		" G\xC3\xB3rska", " Morska", " Zdr\xC3\xB3j", " Woda",
		" Bajoro", " Kraje\xC5\x84ska", " \xC5\x9Al\xC4\x85ska",
		" Mazowiecka", " Pomorska", " Wielka", " Ma\xC5\x82""a",
		" Warmi\xC5\x84ska", " Mazurska", " Mniejsza",
		" Wi\xC4\x99ksza", " G\xC3\xB3rna", " Dolna", " Wielka",
		" Stara", " Nowa", " Wielkopolska", " Wzg\xC3\xB3rza",
		" Mosty", " Kujawska", " Malopolska", " Podlaska",
		" Le\xC5\x9Bna",
	};

	static const char * const names_3_n[] = {
		" Wybudowanie", " \xC5\x9Awietokrzyskie",
		" G\xC3\xB3rskie", " Morskie", " Zdr\xC3\xB3j", " Wody",
		" Bajoro", " Kraje\xC5\x84skie", " \xC5\x9Al\xC4\x85skie",
		" Mazowieckie", " Pomorskie", " Wielkie", " Ma\xC5\x82""e",
		" Warmi\xC5\x84skie ", " Mazurskie ", " Mniejsze",
		" Wi\xC4\x99ksze", " G\xC3\xB3rne", " Dolne", " Wielkie",
		" Stare", " Nowe", " Wielkopolskie", " Wzg\xC3\xB3rze",
		" Mosty", " Kujawskie", " Ma\xC5\x82opolskie", " Podlaskie",
		" Le\xC5\x9Bne",
	};

	/* optional first segment */
	uint i = SeedChance(0,
			lengthof(names_2_o) + lengthof(names_2_m) +
			lengthof(names_2_f) + lengthof(names_2_n),
			seed);
	uint j = SeedChance(2, 20, seed);


	if (i < lengthof(names_2_o)) {
		buf->append (choose_str (names_2_o, seed, 3));
		return;
	}

	if (i < lengthof(names_2_m) + lengthof(names_2_o)) {
		if (j < 4) {
			buf->append (choose_str (names_1_m, seed, 5));
		}

		buf->append (choose_str (names_2_m, seed, 7));

		if (j >= 4 && j < 16) {
			buf->append (choose_str (names_3_m, seed, 10));
		}
	}

	if (i < lengthof(names_2_f) + lengthof(names_2_m) + lengthof(names_2_o)) {
		if (j < 4) {
			buf->append (choose_str (names_1_f, seed, 5));
		}

		buf->append (choose_str (names_2_f, seed, 7));

		if (j >= 4 && j < 16) {
			buf->append (choose_str (names_3_f, seed, 10));
		}

		return;
	}

	if (j < 4) {
		buf->append (choose_str (names_1_n, seed, 5));
	}

	buf->append (choose_str (names_2_n, seed, 7));

	if (j >= 4 && j < 16) {
		buf->append (choose_str (names_3_n, seed, 10));
	}
}


/* The advanced hyperintelligent Czech town names generator!
 * The tables and MakeCzechTownName() is (c) Petr Baudis 2005 (GPL'd)
 * Feel free to ask me about anything unclear or if you need help
 * with cloning this for your own language. */

/* Sing., pl. */
enum CzechGender {
	CZG_SMASC,
	CZG_SFEM,
	CZG_SNEUT,
	CZG_PMASC,
	CZG_PFEM,
	CZG_PNEUT,
	/* Special for substantive stems - the ending chooses the gender. */
	CZG_FREE,
	/* Like CZG_FREE, but disallow CZG_SNEUT. */
	CZG_NFREE
};

enum CzechPattern {
	CZP_JARNI,
	CZP_MLADY,
	CZP_PRIVL
};

/* This way the substantive can choose only some adjectives/endings:
 * At least one of these flags must be satisfied: */
enum CzechAllow {
	CZA_SHORT = 1,
	CZA_MIDDLE = 2,
	CZA_LONG = 4,
	CZA_ALL = ~0
};

DECLARE_ENUM_AS_BIT_SET(CzechAllow)

/* All these flags must be satisfied (in the stem->others direction): */
enum CzechChoose {
	CZC_NONE = 0, // No requirements.
	CZC_COLOR = 1,
	CZC_POSTFIX = 2, // Matched if postfix was inserted.
	CZC_NOPOSTFIX = 4, // Matched if no postfix was inserted.
	CZC_ANY = ~0
};

DECLARE_ENUM_AS_BIT_SET(CzechChoose)

struct CzechNameSubst {
	CzechGender gender;
	CzechAllow allow;
	CzechChoose choose;
	const char *name;
};

struct CzechNameAdj {
	CzechPattern pattern;
	CzechChoose choose;
	const char *name;
};

/**
 * Generates Czech town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeCzechTownName (stringb *buf, uint32 seed)
{
	static const char * const names_real[] = {
		"A\xC5\xA1", "Bene\xC5\xA1ov", "Beroun", "Bezdru\xC5\xBEice",
		"Blansko", "B\xC5\x99""eclav", "Brno", "Brunt\xC3\xA1l",
		"\xC4\x8C""esk\xC3\xA1 L\xC3\xADpa",
		"\xC4\x8C""esk\xC3\xA9 Bud\xC4\x9Bjovice",
		"\xC4\x8C""esk\xC3\xBD Krumlov", "D\xC4\x9B\xC4\x8D\xC3\xADn",
		"Doma\xC5\xBElice", "Dub\xC3\xAD",
		"Fr\xC3\xBD""dek-M\xC3\xADstek",
		"Havl\xC3\xAD\xC4\x8Dk\xC5\xAFv Brod", "Hodon\xC3\xADn",
		"Hradec Kr\xC3\xA1lov\xC3\xA9", "Humpolec", "Cheb",
		"Chomutov", "Chrudim", "Jablonec nad Nisou",
		"Jesen\xC3\xADk", "Ji\xC4\x8D\xC3\xADn", "Jihlava",
		"Jind\xC5\x99ich\xC5\xAFv Hradec", "Karlovy Vary",
		"Karvin\xC3\xA1", "Kladno", "Klatovy", "Kol\xC3\xADn",
		"Kosmonosy", "Krom\xC4\x9B\xC5\x99\xC3\xAD\xC5\xBE",
		"Kutn\xC3\xA1 Hora", "Liberec", "Litom\xC4\x9B\xC5\x99ice",
		"Louny", "Man\xC4\x9Bt\xC3\xADn", "M\xC4\x9Bln\xC3\xADk",
		"Mlad\xC3\xA1 Boleslav", "Most", "N\xC3\xA1""chod",
		"Nov\xC3\xBD Ji\xC4\x8D\xC3\xADn", "Nymburk", "Olomouc",
		"Opava", "Or\xC3\xA1\xC4\x8Dov", "Ostrava", "Pardubice",
		"Pelh\xC5\x99imov", "Pol\xC5\xBEice", "P\xC3\xADsek",
		"Plze\xC5\x88", "Praha", "Prachatice", "P\xC5\x99""erov",
		"P\xC5\x99\xC3\xAD""bram", "Prost\xC4\x9Bjov",
		"Rakovn\xC3\xADk", "Rokycany", "Rudn\xC3\xA1",
		"Rychnov nad Kn\xC4\x9B\xC5\xBEnou", "Semily", "Sokolov",
		"Strakonice", "St\xC5\x99""edokluky", "\xC5\xA0umperk",
		"Svitavy", "T\xC3\xA1""bor", "Tachov", "Teplice",
		"T\xC5\x99""eb\xC3\xAD\xC4\x8D", "Trutnov",
		"Uhersk\xC3\xA9 Hradi\xC5\xA1t\xC4\x9B",
		"\xC3\x9Ast\xC3\xAD nad Labem",
		"\xC3\x9Ast\xC3\xAD nad Orlic\xC3\xAD",
		"Vset\xC3\xADn", "Vy\xC5\xA1kov",
		"\xC5\xBD\xC4\x8F\xC3\xA1r nad S\xC3\xA1zavou",
		"Zl\xC3\xADn", "Znojmo",
	};

	/* [CzechGender][CzechPattern] - replaces the last character of the adjective
	 * by this.
	 * XXX: [CZG_SMASC][CZP_PRIVL] needs special handling: -ovX -> -uv. */
	static const char * const names_patmod[][3] = {
		/* CZG_SMASC */ { "\xC3\xAD", "\xC3\xBD", "X" },
		/* CZG_SFEM  */ { "\xC3\xAD", "\xC3\xA1", "a" },
		/* CZG_SNEUT */ { "\xC3\xAD", "\xC3\xA9", "o" },
		/* CZG_PMASC */ { "\xC3\xAD", "\xC3\xA9", "y" },
		/* CZG_PFEM  */ { "\xC3\xAD", "\xC3\xA9", "y" },
		/* CZG_PNEUT */ { "\xC3\xAD", "\xC3\xA1", "a" }
	};

	/* Some of items which should be common are doubled. */
	static const CzechNameAdj names_adj[] = {
		{ CZP_JARNI, CZC_ANY,   "Horn\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Horn\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Doln\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Doln\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "P\xC5\x99""edn\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Zadn\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Kosteln\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Havran\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "\xC5\x98\xC3\xAD\xC4\x8Dn\xC3\xAD" },
		{ CZP_JARNI, CZC_ANY,   "Jezern\xC3\xAD" },
		{ CZP_MLADY, CZC_ANY,   "Velk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Velk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Mal\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Mal\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Vysok\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "\xC4\x8C""esk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Moravsk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Slov\xC3\xA1""ck\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Slezsk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Uhersk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Star\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Star\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Nov\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Nov\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Mlad\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Kr\xC3\xA1lovsk\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Kamenn\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Cihlov\xC3\xBD" },
		{ CZP_MLADY, CZC_ANY,   "Divn\xC3\xBD" },
		{ CZP_MLADY, CZC_COLOR, "\xC4\x8C""erven\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "\xC4\x8C""erven\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "\xC4\x8C""erven\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "Zelen\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "\xC5\xBDlut\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "Siv\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "\xC5\xA0""ed\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "B\xC3\xADl\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "B\xC3\xADl\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "Modr\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "R\xC5\xAF\xC5\xBEov\xC3\xA1" },
		{ CZP_MLADY, CZC_COLOR, "\xC4\x8C""ern\xC3\xA1" },
		{ CZP_PRIVL, CZC_ANY,   "Kr\xC3\xA1lova" },
		{ CZP_PRIVL, CZC_ANY,   "Janova" },
		{ CZP_PRIVL, CZC_ANY,   "Karlova" },
		{ CZP_PRIVL, CZC_ANY,   "Kry\xC5\xA1tofova" },
		{ CZP_PRIVL, CZC_ANY,   "Ji\xC5\x99\xC3\xADkova" },
		{ CZP_PRIVL, CZC_ANY,   "Petrova" },
		{ CZP_PRIVL, CZC_ANY,   "Sudovo" },
	};

	/* Considered a stem for choose/allow matching purposes. */
	static const CzechNameSubst names_subst_full[] = {
		{ CZG_SMASC, CZA_ALL, CZC_COLOR, "Sedlec" },
		{ CZG_SMASC, CZA_ALL, CZC_COLOR, "Brod" },
		{ CZG_SMASC, CZA_ALL, CZC_COLOR, "Brod" },
		{ CZG_SMASC, CZA_ALL, CZC_NONE,  "\xC3\x9Aval" },
		{ CZG_SMASC, CZA_ALL, CZC_COLOR, "\xC5\xBD\xC4\x8F\xC3\xA1r" },
		{ CZG_SMASC, CZA_ALL, CZC_COLOR, "Smrk" },
		{ CZG_SFEM,  CZA_ALL, CZC_COLOR, "Hora" },
		{ CZG_SFEM,  CZA_ALL, CZC_COLOR, "Lhota" },
		{ CZG_SFEM,  CZA_ALL, CZC_COLOR, "Lhota" },
		{ CZG_SFEM,  CZA_ALL, CZC_COLOR, "Hlava" },
		{ CZG_SFEM,  CZA_ALL, CZC_COLOR, "L\xC3\xADpa" },
		{ CZG_SNEUT, CZA_ALL, CZC_COLOR, "Pole" },
		{ CZG_SNEUT, CZA_ALL, CZC_COLOR, "\xC3\x9A""dol\xC3\xAD" },
		{ CZG_PMASC, CZA_ALL, CZC_NONE,  "\xC3\x9Avaly" },
		{ CZG_PFEM,  CZA_ALL, CZC_COLOR, "Luka" },
		{ CZG_PNEUT, CZA_ALL, CZC_COLOR, "Pole" },
	};

	/* TODO: More stems needed. --pasky */
	static const CzechNameSubst names_subst_stem[] = {
		{ CZG_SMASC,             CZA_MIDDLE,            CZC_COLOR, "Kostel" },
		{ CZG_SMASC,             CZA_MIDDLE,            CZC_COLOR, "Kl\xC3\xA1\xC5\xA1ter" },
		{ CZG_SMASC, CZA_SHORT,                         CZC_COLOR, "Lhot" },
		{ CZG_SFEM,  CZA_SHORT,                         CZC_COLOR, "Lhot" },
		{ CZG_SFEM,  CZA_SHORT,                         CZC_COLOR, "Hur" },
		{ CZG_FREE,              CZA_MIDDLE | CZA_LONG, CZC_NONE,  "Sedl" },
		{ CZG_FREE,  CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_COLOR, "Hrad" },
		{ CZG_NFREE,             CZA_MIDDLE,            CZC_NONE,  "Pras" },
		{ CZG_NFREE,             CZA_MIDDLE,            CZC_NONE,  "Ba\xC5\xBE" },
		{ CZG_NFREE,             CZA_MIDDLE,            CZC_NONE,  "Tes" },
		{ CZG_NFREE,             CZA_MIDDLE,            CZC_NONE,  "U\xC5\xBE" },
		{ CZG_NFREE,             CZA_MIDDLE | CZA_LONG, CZC_POSTFIX, "B\xC5\x99" },
		{ CZG_NFREE,             CZA_MIDDLE | CZA_LONG, CZC_NONE,  "Vod" },
		{ CZG_NFREE,             CZA_MIDDLE | CZA_LONG, CZC_NONE,  "Jan" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Prach" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Kunr" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Strak" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "V\xC3\xADt" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Vy\xC5\xA1" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "\xC5\xBD""at" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "\xC5\xBD""er" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "St\xC5\x99""ed" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Harv" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Pruh" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Tach" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "P\xC3\xADsn" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Jin" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Jes" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Jar" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Sok" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Hod" },
		{ CZG_NFREE,                          CZA_LONG, CZC_NONE,  "Net" },
		{ CZG_FREE,                           CZA_LONG, CZC_NONE,  "Pra\xC5\xBE" },
		{ CZG_FREE,                           CZA_LONG, CZC_NONE,  "Nerat" },
		{ CZG_FREE,                           CZA_LONG, CZC_NONE,  "Kral" },
		{ CZG_FREE,                           CZA_LONG, CZC_NONE,  "Hut" },
		{ CZG_FREE,                           CZA_LONG, CZC_NOPOSTFIX, "Pan" },
		{ CZG_FREE,  CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_NOPOSTFIX, "Odst\xC5\x99""ed" },
		{ CZG_FREE,  CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_COLOR, "Mrat" },
		{ CZG_FREE,                           CZA_LONG, CZC_COLOR, "Hlav" },
		{ CZG_FREE,  CZA_SHORT | CZA_MIDDLE,            CZC_NONE,  "M\xC4\x9B\xC5\x99" },
		{ CZG_FREE,              CZA_MIDDLE | CZA_LONG, CZC_NONE,  "Lip" },
	};

	/* Optional postfix inserted between stem and ending. */
	static const char * const names_subst_postfix[] = {
		"av", "an", "at",
		"ov", "on", "ot",
		"ev", "en", "et",
	};

	/* This array must have the both neutral genders at the end! */
	static const CzechNameSubst names_subst_ending[] = {
		{ CZG_SMASC, CZA_SHORT | CZA_MIDDLE,            CZC_ANY, "ec" },
		{ CZG_SMASC, CZA_SHORT | CZA_MIDDLE,            CZC_ANY, "\xC3\xADn" },
		{ CZG_SMASC, CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_ANY, "ov" },
		{ CZG_SMASC, CZA_SHORT       |        CZA_LONG, CZC_ANY, "kov" },
		{ CZG_SMASC,                          CZA_LONG, CZC_POSTFIX, "\xC3\xADn" },
		{ CZG_SMASC,                          CZA_LONG, CZC_POSTFIX, "n\xC3\xADk" },
		{ CZG_SMASC,                          CZA_LONG, CZC_ANY, "burk" },
		{ CZG_SFEM,  CZA_SHORT,                         CZC_ANY, "ka" },
		{ CZG_SFEM,              CZA_MIDDLE,            CZC_ANY, "inka" },
		{ CZG_SFEM,              CZA_MIDDLE,            CZC_ANY, "n\xC3\xA1" },
		{ CZG_SFEM,                           CZA_LONG, CZC_ANY, "ava" },
		{ CZG_PMASC,                          CZA_LONG, CZC_POSTFIX, "\xC3\xADky" },
		{ CZG_PMASC,                          CZA_LONG, CZC_ANY, "upy" },
		{ CZG_PMASC,                          CZA_LONG, CZC_ANY, "olupy" },
		{ CZG_PFEM,                           CZA_LONG, CZC_ANY, "avy" },
		{ CZG_PFEM,  CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_ANY, "ice" },
		{ CZG_PFEM,  CZA_SHORT | CZA_MIDDLE | CZA_LONG, CZC_ANY, "i\xC4\x8Dky" },
		{ CZG_PNEUT, CZA_SHORT | CZA_MIDDLE,            CZC_ANY, "na" },
		{ CZG_SNEUT, CZA_SHORT | CZA_MIDDLE,            CZC_ANY, "no" },
		{ CZG_SNEUT,                          CZA_LONG, CZC_ANY, "i\xC5\xA1t\xC4\x9B" },
	};

	static const char * const names_suffix[] = {
		"nad Cidlinou", "nad Dyj\xC3\xAD", "nad Jihlavou",
		"nad Labem", "nad Lesy", "nad Moravou", "nad Nisou",
		"nad Odrou", "nad Ostravic\xC3\xAD", "nad S\xC3\xA1zavou",
		"nad Vltavou", "pod Prad\xC4\x9B""dem",
		"pod Radho\xC5\xA1t\xC4\x9Bm", "pod \xC5\x98\xC3\xADpem",
		"pod Sn\xC4\x9B\xC5\xBEkou",
		"pod \xC5\xA0pi\xC4\x8D\xC3\xA1kem", "pod Sedlem",
		"v \xC4\x8C""ech\xC3\xA1""ch", "na Morav\xC4\x9B",
	};

	/* 1:3 chance to use a real name. */
	if (SeedModChance(0, 4, seed) == 0) {
		buf->append (choose_str_mod (names_real, seed, 4));
		return;
	}

	/* Probability of prefixes/suffixes
	 * 0..11 prefix, 12..13 prefix+suffix, 14..17 suffix, 18..31 nothing */
	int prob_tails = SeedModChance(2, 32, seed);
	bool do_prefix = prob_tails < 12;
	bool do_suffix = prob_tails > 11 && prob_tails < 17;
	bool dynamic_subst;

	/* IDs of the respective parts */
	int prefix = 0, ending = 0, suffix = 0;
	uint postfix = 0;
	uint stem;

	/* The select criteria. */
	CzechGender gender;
	CzechChoose choose;
	CzechAllow allow;

	if (do_prefix) prefix = SeedModChance(5, lengthof(names_adj) * 12, seed) / 12;
	if (do_suffix) suffix = SeedModChance(7, lengthof(names_suffix), seed);
	/* 3:1 chance 3:1 to use dynamic substantive */
	stem = SeedModChance(9,
			lengthof(names_subst_full) + 3 * lengthof(names_subst_stem),
			seed);
	if (stem < lengthof(names_subst_full)) {
		/* That was easy! */
		dynamic_subst = false;
		gender = names_subst_full[stem].gender;
		choose = names_subst_full[stem].choose;
		allow  = names_subst_full[stem].allow;
	} else {
		unsigned int map[lengthof(names_subst_ending)];
		int ending_start = -1, ending_stop = -1;

		/* Load the substantive */
		dynamic_subst = true;
		stem -= lengthof(names_subst_full);
		stem %= lengthof(names_subst_stem);
		gender = names_subst_stem[stem].gender;
		choose = names_subst_stem[stem].choose;
		allow  = names_subst_stem[stem].allow;

		/* Load the postfix (1:1 chance that a postfix will be inserted) */
		postfix = SeedModChance(14, lengthof(names_subst_postfix) * 2, seed);

		if (choose & CZC_POSTFIX) {
			/* Always get a real postfix. */
			postfix %= lengthof(names_subst_postfix);
		}
		if (choose & CZC_NOPOSTFIX) {
			/* Always drop a postfix. */
			postfix += lengthof(names_subst_postfix);
		}
		if (postfix < lengthof(names_subst_postfix)) {
			choose |= CZC_POSTFIX;
		} else {
			choose |= CZC_NOPOSTFIX;
		}

		/* Localize the array segment containing a good gender */
		for (ending = 0; ending < (int)lengthof(names_subst_ending); ending++) {
			const CzechNameSubst *e = &names_subst_ending[ending];

			if (gender == CZG_FREE ||
					(gender == CZG_NFREE && e->gender != CZG_SNEUT && e->gender != CZG_PNEUT) ||
					 gender == e->gender) {
				if (ending_start < 0) {
					ending_start = ending;
				}
			} else if (ending_start >= 0) {
				ending_stop = ending - 1;
				break;
			}
		}
		if (ending_stop < 0) {
			/* Whoa. All the endings matched. */
			ending_stop = ending - 1;
		}

		/* Make a sequential map of the items with good mask */
		size_t i = 0;
		for (ending = ending_start; ending <= ending_stop; ending++) {
			const CzechNameSubst *e = &names_subst_ending[ending];

			if ((e->choose & choose) == choose && (e->allow & allow) != 0) {
				map[i++] = ending;
			}
		}
		assert(i > 0);

		/* Load the ending */
		ending = map[SeedModChance(16, (int)i, seed)];
		/* Override possible CZG_*FREE; this must be a real gender,
		 * otherwise we get overflow when modifying the adjectivum. */
		gender = names_subst_ending[ending].gender;
		assert(gender != CZG_FREE && gender != CZG_NFREE);
	}

	if (do_prefix && (names_adj[prefix].choose & choose) != choose) {
		/* Throw away non-matching prefix. */
		do_prefix = false;
	}

	/* Now finally construct the name */
	if (do_prefix) {
		size_t orig_length = buf->length();

		CzechPattern pattern = names_adj[prefix].pattern;

		buf->append (names_adj[prefix].name);

		assert (!buf->empty());
		size_t end_length = buf->length() - 1;
		/* Find the first character in a UTF-8 sequence */
		while (GB(buf->buffer[end_length], 6, 2) == 2) end_length--;

		if (gender == CZG_SMASC && pattern == CZP_PRIVL) {
			assert (end_length >= orig_length + 2);
			/* -ovX -> -uv */
			buf->buffer[end_length - 2] = 'u';
			assert(buf->buffer[end_length - 1] == 'v');
			buf->truncate (end_length);
		} else {
			assert (end_length >= orig_length);
			buf->append (names_patmod[gender][pattern]);
		}

		buf->append (' ');
	}

	if (dynamic_subst) {
		buf->append (names_subst_stem[stem].name);
		if (postfix < lengthof(names_subst_postfix)) {
			const char *poststr = names_subst_postfix[postfix];
			const char *endstr  = names_subst_ending[ending].name;

			size_t postlen = strlen(poststr);
			size_t endlen = strlen(endstr);
			assert(postlen > 0 && endlen > 0);

			/* Kill the "avava" and "Jananna"-like cases */
			if (postlen < 2 || postlen > endlen ||
					((poststr[1] != 'v' || poststr[1] != endstr[1]) &&
					poststr[2] != endstr[1])) {
				buf->append (poststr);

				/* k-i -> c-i, h-i -> z-i */
				if (endstr[0] == 'i') {
					assert (!buf->empty());
					char *last = &buf->buffer[buf->length() - 1];
					switch (*last) {
						case 'k': *last = 'c'; break;
						case 'h': *last = 'z'; break;
						default: break;
					}
				}
			}
		}
		buf->append (names_subst_ending[ending].name);
	} else {
		buf->append (names_subst_full[stem].name);
	}

	if (do_suffix) {
		buf->append (' ');
		buf->append (names_suffix[suffix]);
	}
}


/**
 * Generates Romanian town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeRomanianTownName (stringb *buf, uint32 seed)
{
	buf->append (choose_str (_name_romanian_real, seed, 0));
}


/**
 * Generates Slovak town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeSlovakTownName (stringb *buf, uint32 seed)
{
	buf->append (choose_str (_name_slovak_real, seed, 0));
}


/**
 * Generates Norwegian town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeNorwegianTownName (stringb *buf, uint32 seed)
{
	/* Use first 4 bit from seed to decide whether or not this town should
	 * have a real name 3/16 chance.  Bit 0-3 */
	if (SeedChance(0, 15, seed) < 3) {
		/* Use 7bit for the realname table index.  Bit 4-10 */
		buf->append (choose_str (_name_norwegian_real, seed, 4));
		return;
	}

	/* Use 7bit for the first fake part.  Bit 4-10 */
	buf->append (choose_str (_name_norwegian_1, seed,  4));
	/* Use 7bit for the last fake part.  Bit 11-17 */
	buf->append (choose_str (_name_norwegian_2, seed, 11));
}


/**
 * Generates Hungarian town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeHungarianTownName (stringb *buf, uint32 seed)
{
	if (SeedChance(12, 15, seed) < 3) {
		buf->append (choose_str (_name_hungarian_real, seed, 0));
		return;
	}

	/* optional first segment */
	uint i = SeedChance(3, lengthof(_name_hungarian_1) * 3, seed);
	if (i < lengthof(_name_hungarian_1)) buf->append (_name_hungarian_1[i]);

	/* mandatory middle segments */
	buf->append (choose_str (_name_hungarian_2, seed, 3));
	buf->append (choose_str (_name_hungarian_3, seed, 6));

	/* optional last segment */
	i = SeedChance(10, lengthof(_name_hungarian_4) * 3, seed);
	if (i < lengthof(_name_hungarian_4)) {
		buf->append (_name_hungarian_4[i]);
	}
}


/**
 * Generates Swiss town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeSwissTownName (stringb *buf, uint32 seed)
{
	buf->append (choose_str (_name_swiss_real, seed, 0));
}


/**
 * Generates Danish town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeDanishTownName (stringb *buf, uint32 seed)
{
	/* optional first segment */
	append_opt (buf, _name_danish_1, seed, 0, 50);

	/* middle segments removed as this algorithm seems to create much more realistic names */
	buf->append (choose_str (_name_danish_2, seed,  7));
	buf->append (choose_str (_name_danish_3, seed, 16));
}


/**
 * Generates Turkish town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeTurkishTownName (stringb *buf, uint32 seed)
{
	uint i = SeedModChance(0, 5, seed);

	switch (i) {
		case 0:
			buf->append (choose_str_mod (_name_turkish_prefix, seed, 2));

			/* middle segment */
			buf->append (choose_str_mod (_name_turkish_middle, seed, 4));

			/* optional suffix */
			if (SeedModChance(0, 7, seed) == 0) {
				buf->append (choose_str_mod (_name_turkish_suffix, seed, 10));
			}
			break;

		case 1: case 2:
			buf->append (choose_str_mod (_name_turkish_prefix, seed, 2));
			buf->append (choose_str_mod (_name_turkish_suffix, seed, 4));
			break;

		default:
			buf->append (choose_str_mod (_name_turkish_real, seed, 4));
			break;
	}
}


/**
 * Generates Italian town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeItalianTownName (stringb *buf, uint32 seed)
{
	if (SeedModChance(0, 6, seed) == 0) { // real city names
		buf->append (choose_str_mod (_name_italian_real, seed, 4));
		return;
	}

	static const char mascul_femin_italian[2] = { 'o', 'a' };

	if (SeedModChance(0, 8, seed) == 0) { // prefix
		buf->append (choose_str_mod (_name_italian_pref, seed, 11));
	}

	uint i = SeedChance(0, 2, seed);
	if (i == 0) { // masculine form
		buf->append (choose_str_mod (_name_italian_1m, seed, 4));
	} else { // feminine form
		buf->append (choose_str_mod (_name_italian_1f, seed, 4));
	}

	if (SeedModChance(3, 3, seed) == 0) {
		buf->append (choose_str_mod (_name_italian_2, seed, 11));
		buf->append (mascul_femin_italian[i]);
	} else {
		buf->append (choose_str_mod (_name_italian_2i, seed, 16));
	}

	if (SeedModChance(15, 4, seed) == 0) {
		if (SeedModChance(5, 2, seed) == 0) { // generic suffix
			buf->append (choose_str_mod (_name_italian_3, seed, 4));
		} else { // river name suffix
			buf->append (choose_str_mod (_name_italian_river1, seed,  4));
			buf->append (choose_str_mod (_name_italian_river2, seed, 16));
		}
	}
}


/**
 * Generates Catalan town name from given seed.
 * @param buf output buffer
 * @param seed town name seed
 */
static void MakeCatalanTownName (stringb *buf, uint32 seed)
{
	if (SeedModChance(0, 3, seed) == 0) { // real city names
		buf->append (choose_str_mod (_name_catalan_real, seed, 4));
		return;
	}

	if (SeedModChance(0, 2, seed) == 0) { // prefix
		buf->append (choose_str_mod (_name_catalan_pref, seed, 11));
	}

	uint i = SeedChance(0, 2, seed);
	if (i == 0) { // masculine form
		buf->append (choose_str_mod (_name_catalan_1m, seed,  4));
		buf->append (choose_str_mod (_name_catalan_2m, seed, 11));
	} else { // feminine form
		buf->append (choose_str_mod (_name_catalan_1f, seed,  4));
		buf->append (choose_str_mod (_name_catalan_2f, seed, 11));
	}

	if (SeedModChance(15, 5, seed) == 0) {
		if (SeedModChance(5, 2, seed) == 0) { // generic suffix
			buf->append (choose_str_mod (_name_catalan_3, seed, 4));
		} else { // river name suffix
			buf->append (choose_str_mod (_name_catalan_river1, seed, 4));
		}
	}
}


/**
 * Type for all town name generator functions.
 * @param buf  The buffer to write the name to.
 * @param seed The seed of the town name.
 */
typedef void TownNameGenerator (stringb *buf, uint32 seed);

/** Contains pointer to generator and minimum buffer size (not incl. terminating '\0') */
struct TownNameGeneratorParams {
	byte min; ///< minimum number of characters that need to be printed for generator to work correctly
	TownNameGenerator *proc; ///< generator itself
};

/** Town name generators */
static const TownNameGeneratorParams _town_name_generators[] = {
	{  4, MakeEnglishOriginalTownName},  // replaces first 4 characters of name
	{  0, MakeFrenchTownName},
	{  0, MakeGermanTownName},
	{  4, MakeEnglishAdditionalTownName}, // replaces first 4 characters of name
	{  0, MakeSpanishTownName},
	{  0, MakeSillyTownName},
	{  0, MakeSwedishTownName},
	{  0, MakeDutchTownName},
	{  8, MakeFinnishTownName}, // names_1
	{  0, MakePolishTownName},
	{  0, MakeSlovakTownName},
	{  0, MakeNorwegianTownName},
	{  0, MakeHungarianTownName},
	{  0, MakeAustrianTownName},
	{  0, MakeRomanianTownName},
	{ 28, MakeCzechTownName}, // names_adj + names_patmod + 1 + names_subst_stem + names_subst_postfix
	{  0, MakeSwissTownName},
	{  0, MakeDanishTownName},
	{  0, MakeTurkishTownName},
	{  0, MakeItalianTownName},
	{  0, MakeCatalanTownName},
};


/**
 * Generates town name from given seed. a language.
 * @param buf output buffer
 * @param lang town name language
 * @param seed generation seed
 */
void GenerateTownNameString (stringb *buf, size_t lang, uint32 seed)
{
	assert(lang < lengthof(_town_name_generators));

	/* Some generators need at least 9 bytes in buffer.  English generators need 5 for
	 * string replacing, others use constructions like strlen(buf)-3 and so on.
	 * Finnish generator needs to fit all strings from names_1.
	 * Czech generator needs to fit almost whole town name...
	 * These would break. Using another temporary buffer results in ~40% slower code,
	 * so use it only when really needed. */
	const TownNameGeneratorParams *par = &_town_name_generators[lang];
	if (buf->capacity > par->min) {
		par->proc (buf, seed);
		return;
	}

	char *buffer = AllocaM(char, par->min + 1);
	stringb tmp (par->min + 1, buffer);
	par->proc (&tmp, seed);

	buf->append (buffer);
}
